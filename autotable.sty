\ProvidesPackage{autotable}[2020/02/21 autotable]

% ----------------------------------------------------------------------------
% "THE COFFEEWARE LICENSE":
% Adrian Rettich (adrian.rettich@gmail.com) wrote this file. As long as you 
% retain this notice, you can do whatever you want with this stuff. If we 
% should meet in person some day, and you think this stuff is worth it, you 
% are welcome to buy me a coffee in return.  
% ----------------------------------------------------------------------------


\RequirePackage{pgfopts}
%\RequirePackage{ifthen}
\RequirePackage{xparse} % is awesome, provides NewDocumentCommand
\RequirePackage{tabularx} % makes nice tables, needed for the fancy autotable
\RequirePackage{zref-savepos} % for calculating the available space on the page for autofilling with a table
%\RequirePackage{zref}
\RequirePackage{xifthen} % provides numerical comparison in ifthenelse
%\RequirePackage{pgffor}
\RequirePackage{pgfplots}



% AND NOW THE KEYS
\pgfkeys{
	/autotable/.cd,
	.unknown/.code={
		\ifthenelse{\equal{\pgfkeyscurrentvalue}{\pgfkeysnovalue}}{
			\edef\@pemberleyunknown{\@pemberleyunknown,\pgfkeyscurrentname}
		}{
			\edef\@pemberleyunknown{\@pemberleyunknown,\pgfkeyscurrentname=\pgfkeyscurrentvalue}
		}
	}
}

\ProcessPgfPackageOptions{/autotable}
\relax



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TABLE STUFF %%%%%%%%%%%%%%%                
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% here's a for loop macro.
% why not use pgffor? because that didn't work with tabularx.
% #1: start
% #2: end
% #3: what to do
\newcounter{@ifor}
\newcommand\@@for[3]{%
    \setcounter{@ifor}{#1}%
    % we test for >(k-1) because this is equivalent to >=k for k integer, and equivalent to >=floor(k) for k not integer, which is precisely what I want the for loop to do: for{1}{1} is evaluated once, for{1}{2} twice, and for{1}{1.9} once.
    % only caveat: any for loop is always executed at least once, even if end<start. This is necessary because otherwise the tabularx contains half a row (with vertical, but no horizontal lines) that I am unable to get rid of.
    \ifthenelse{\cnttest{\the@ifor}{>}{\numexpr#2-1\relax}}{%
        #3% we're done!
    }{%
        #3%
        \addtocounter{@ifor}{1}%
        \@@for{\the@ifor}{#2}{#3}%
    }%
}

% the following hack makes it possible to expand the preamble of tabularx.   
\newenvironment{@parametrizedtabularx}[1]{%
    \tabularx{\textwidth}{#1}\hline}{\endtabularx}

\newcommand\@@beginparametrizedtabularx[1]{\begin{@parametrizedtabularx}{#1}}

\newcommand\@beginparametrizedtabularx[1]{\expandafter\@@beginparametrizedtabularx\expandafter{#1}}

\newcommand\@endparametrizedtabularx{\end{@parametrizedtabularx}}

% auxiliary flags and commands
\newif\if@firstcolumn
\newif\if@firstcolumntitle
\newif\if@autotablecalled
\newlength\@listheight
\newlength\@listspace
\newcounter{@listfilllabels}
\setcounter{@listfilllabels}{0}

%%%%%%%
%%% NON-AUXILIARY STUFF STARTS HERE
%%%%%%%

% should line numbers be printed?                
\newif\if@countlines
\newcommand\countlines{\@countlinestrue}
\newcommand\nocountlines{\@countlinesfalse}
\newcommand\countrows{\@countlinestrue}
\newcommand\nocountrows{\@countlinesfalse}

% if they are printed, how are line numbers formatted?
% redefine \linecountformat for other variants.
\newcommand\linecountformat[1]{#1}
\def\@linecount{
    \if@countlines
        \linecountformat{\the@ifor}
    \fi
}

% should a title row be included?
\newif\if@titles

% count which col/title was installed last:
\newcounter{@columns}
\newcounter{@titles}
\NewDocumentCommand\autotablereset{}{
    \def\@colspec{|} % saves the tabularx preamble
    \def\@linespec{} % saves the layout of a single row
    \def\@titlerow{} % saves the layout of the title row
    \@countlinesfalse
    \@titlesfalse
   % \@firstcolumntrue
   % \@firstcolumntitletrue
    \let\@columnlist\empty
    \let\@titlelist\empty
    \@autotablecalledfalse
    \setcounter{@columns}{0}
    \setcounter{@titles}{0}
}

% call this to install a new column spec.
% edit: never call this except in @columnlisthandler.
\NewDocumentCommand\@@autocolumn{m}{
    \edef\@colspec{|#1\@colspec}
    \if@firstcolumn
        %\def\@titlerow{#2}
        \@firstcolumnfalse
    \else
        %\edef\@titlerow{#2&\@titlerow}
        \edef\@linespec{&\@linespec}
    \fi
}

\NewDocumentCommand\@queuecolumn{m}{
    % note: we could just test whether columnlist is empty, but this is not possible in \@queuetitle (see there), so we use this test here for consistency.
    \ifthenelse{\equal{\the@columns}{0}}{
        \xdef\@columnlist{#1}%
    }{
        \xdef\@columnlist{#1,\@columnlist}%
    }
    \stepcounter{@columns}
}

% call this to install a title for a column.
% if this is not called either 0 or n times, where n is the number of columns, then bad things might happen. Who knows.
% edit: never call this except in @columnlisthandler.
\NewDocumentCommand\@@autocolumntitle{m}{
    \if@firstcolumntitle
        \def\@titlerow{#1}
        \@firstcolumntitlefalse
    \else
        \edef\@titlerow{#1&\@titlerow}
    \fi
}

\NewDocumentCommand\@queuetitle{m}{
    % note: we can NOT test for \titlelist = \empty here! Reason: adding an empty title would not change that status.
    \ifthenelse{\equal{\the@titles}{0}}{
        \xdef\@titlelist{#1}%
    }{
        \xdef\@titlelist{#1,\@titlelist}%
    }
    \stepcounter{@titles}
}

\newcommand\@columnlisthandler{
    \PackageWarning{??????????????????????????????}{titles \the@titles \@titlelist}
    \PackageWarning{??????????????????????????????}{columns \the@columns \@columnlist}
    \ifthenelse{\cnttest{\the@titles}{>}{\the@columns}}{
        \PackageError{autotable}{number of titles greater than number of columns}{}
    }{}
    \ifthenelse{\equal{\the@titles}{0}}{
        \@titlesfalse
    }{
        \@titlestrue
    }
    \ifthenelse{\cnttest{\the@titles}{<}{\the@columns}}{
        \@queuetitlehere{}
    }

    \@firstcolumntrue
    \@firstcolumntitletrue
    \expandafter\pgfplotsinvokeforeach\expandafter{\@columnlist}{\@@autocolumn{##1}}
    \expandafter\pgfplotsinvokeforeach\expandafter{\@titlelist}{\@@autocolumntitle{##1}}
}

% installs a title, but at the last-installed column.
\NewDocumentCommand\@queuetitlehere{m}{
    \ifthenelse{\cnttest{\the@titles}{>=}{\the@columns}}{
        \PackageError{autotable}{more titles than columns}{}
    }{}
    \ifthenelse{\cnttest{\the@titles}{<}{\numexpr\the@columns - 1}}{
        \@queuetitle{}
        \@queuetitlehere{#1}
    }{
        \@queuetitle{#1}
    }
}

\NewDocumentCommand\@filltitles{}{
    \ifthenelse{\equal{\the@titles}{\the@columns}}{
        % already enough titles; do nothing
    }{
        % not enough titles, fill with empty ones
        \@queuetitlehere{}
    }
}


% end users should call this to install a column.
\NewDocumentCommand\autocolumn{mo}{
    \@queuecolumn{#1}
    \IfNoValueTF{#2}{}{
        \@queuetitlehere{#2}
    }
}

% this should install multiple columns.
% note: this reverses the order for some reason, so queueing them as submitted works, even though I was certain it would not.
\NewDocumentCommand\autocolumns{mo}{
    \IfNoValueTF{#2}{}{
        \@filltitles
    }
    \pgfplotsinvokeforeach{#1}{\@queuecolumn{##1}}
    \IfNoValueTF{#2}{}{
        \pgfplotsinvokeforeach{#2}{\@queuetitle{##1}}
        \@filltitles
     }
}


\def\@lncount{-1}
\zref@newprop{autotablelinecount}{-1}
% #1: number of lines
% 0 lines means only title row (if any)
% {} lines means autofill the page
\NewDocumentCommand\autotable{m}{
    \if@autotablecalled\else
        \@columnlisthandler
    \fi

    \@autotablecalledtrue

    \@generatetableheight{#1}

    % if @lncount is negative, do not create a table at all. Otherwise, at least the header row is generated (if headers were set)
%    \@maybebegintabular
%    \@maybeendtabular

    \ifthenelse{\cnttest{\@lncount}{<}{0}}{}{%
        \@beginparametrizedtabularx{\@colspec}%
            \if@titles\@titlerow\\\hline\fi%
            \@generaterows{\@lncount}%
       \end{@parametrizedtabularx}}
}

%\newenvironment{autotabular}[2]{%
%    \@generatetableheight{#2}%
%    \edef\@tmpct{\@lncount}
%    \ifthenelse{\cnttest{\@tmpct}{<}{0}}{}{%
%        \@beginparametrizedtabularx{#1}%
%%            \if@titles\@titlerow\\\hline\fi%
%    %        \@generaterows{\@tmpct}%
%    }
%%    %
%    }{%
%    \ifthenelse{\cnttest{\@tmpct}{<}{0}}{}{%
%        \@endparametrizedtabularx}%
%        }



\newcommand\@generatetableheight[1]{
    \ifthenelse{\equal{#1}{}}{
        \@autogeneratetableheight
    }{
        \def\@lncount{#1}
    }
}

\newcommand\@autogeneratetableheight{
        \stepcounter{@listfilllabels}
        \zifrefundefined{autotablelinecount\the@listfilllabels}{
        % the counter is only here to differentiate between labels of multiple autotables in the same document.
        % label not defined yet => we are in the first run (no aux file) and should compute the desired height.
        \zifrefundefined{listtop\the@listfilllabels}{
            \@beginparametrizedtabularx{\@colspec}
            \zsavepos{listtop\the@listfilllabels}
                \@linespec\\\hline
            \zsavepos{listbottom\the@listfilllabels}
            \end{@parametrizedtabularx}
            \vfill
            \zsavepos{pagebottom\the@listfilllabels}
            \def\@lncount{-1}
        }{
        % label is defined => we found an aux file and hence know how large the table can be.
            % for reasons unknown to me, if you have more than one autofill table in one document, the second \@listheight computation yields a wrong (too large) result. For this reason, we always use listtop1 and listbottom1 to compute listheight, because that always seems to be correct.
            %\edef\@listheight{\dimexpr\zposy{listtop\the@listfilllabels}sp-\zposy{listbottom\the@listfilllabels}sp\relax} % note: this length is positive
            \edef\@listheight{\dimexpr\zposy{listtop1}sp-\zposy{listbottom1}sp\relax} % note: this length is positive
            \edef\@listspace{\dimexpr\zposy{listtop\the@listfilllabels}sp-\zposy{pagebottom\the@listfilllabels}sp\relax}

            \xdef\@div{\numexpr\@listspace / \@listheight}
            \if@titles
                \def\@divoffset{1}
            \else
                \def\@divoffset{0}
            \fi
            \def\@@div{\numexpr\@div-\@divoffset}
            \edef\@lncount{\@@div}
        \zref@setcurrent{autotablelinecount}{\@lncount}
        \zref@labelbyprops{autotablelinecount\the@listfilllabels}{autotablelinecount}
        }
    }
    {
        % autotablelinecount already defined => use that number instead
        \def\@lncount{\zref@extract{autotablelinecount\the@listfilllabels}{autotablelinecount}}
        \zref@setcurrent{autotablelinecount}{\@lncount}
        \zref@labelbyprops{autotablelinecount\the@listfilllabels}{autotablelinecount}
    }
}

\newcommand\@generaterows[1]{%
    \ifthenelse{\cnttest{#1}{>}{0}}{%
    \@@for{1}{#1}{\@linecount\@linespec\\\hline}%
    }{}%
}

\autotablereset


\endinput
