\documentclass[xcolor={dvipsnames}]{beamer}

% Warning: this needs XeLaTeX to load ptsans I was here
\usetheme[FB=Mathematik,navigation=true]{TUKL}
\setbeamercolor{block title}{fg=black,bg=tukldeptbg}
\setbeamercolor{block body}{fg=black,bg=tukldeptbg!40}
\setbeamertemplate{blocks}[rounded][shadow=false]
\setbeamercolor{structure}{fg=tuklblue}

\usepackage{etoolbox}





% hack to make navigation in the header span two rows
\makeatletter
\def\insertnavigation#1#2#3{%
	 \hbox to #1{{%
		    \def\slideentry##1##2##3##4##5##6{}%
			   #2\hskip.3cm%
			      \newdimen\tmp@parbox%
				     \setlength\tmp@parbox{#1}%
					    \addtolength\tmp@parbox{-.6cm}%
						   \parbox{\tmp@parbox}{\raggedright%
						        \usebeamerfont{section in head/foot}\usebeamercolor[fg]{section in head/foot}%
								     \setbox\beamer@sectionbox=\hbox{}%
									      \ht\beamer@sectionbox=1.875ex%
										       \dp\beamer@sectionbox=0.75ex%
											        \hskip-1.875ex plus-1fill\dohead%
													     \box\beamer@sectionbox}\hfil\hskip.3cm%
														      #3}}}
															  \makeatother



\usepackage{xparse}

\usepackage{tikz}
\usepackage{pgfplots}
 \usepgflibrary{arrows.meta}
 \usepgfplotslibrary{fillbetween}
\usetikzlibrary{calc,decorations.pathmorphing,decorations.text,patterns,intersections,shapes.geometric}
%\usetikzlibrary{external}
%\tikzset{/tikz/external/optimize=false}
%\tikzexternalize

\pgfdeclarelayer{grid}
\pgfdeclarelayer{bg}
\pgfdeclarelayer{bga}
\pgfdeclarelayer{fg}
\pgfsetlayers{bg,bga,grid,main,fg}

\makeatletter

\pgfdeclaredecoration{penciline}{initial}{
\state{initial}[width=+\pgfdecoratedinputsegmentremainingdistance,auto corner on length=1mm,]{
\pgfpathcurveto%
	{% From
\pgfqpoint{\pgfdecoratedinputsegmentremainingdistance}
{\pgfdecorationsegmentamplitude}
}
{%  Control 1
\pgfmathrand
\pgfpointadd{\pgfqpoint{\pgfdecoratedinputsegmentremainingdistance}{0pt}}
{\pgfqpoint{-\pgfdecorationsegmentaspect\pgfdecoratedinputsegmentremainingdistance}%
{\pgfmathresult\pgfdecorationsegmentamplitude}
}
}
{%TO 
\pgfpointadd{\pgfpointdecoratedinputsegmentlast}{\pgfpoint{1pt}{1pt}}
}
}
\state{final}{}
}
\makeatother


\usetikzlibrary{babel}


\usepackage{emerald}
\tikzset{every node/.append style={font=\ECFAugie}}
\tikzset{mylabel/.style={label=below:{#1},inner sep=0pt,outer sep=0pt,font=\ECFAugie}}




%%%%%%%%%%%%%%%%%%%%%%%
% CUSTOM COMMANDS     %
%%%%%%%%%%%%%%%%%%%%%%%


\newcommand\tikzfont\ECFAugie




\thinmuskip=1mu\relax
\medmuskip=2mu\relax
\thickmuskip=3mu\relax

\renewcommand{\colon}{\nobreak\mskip2mu\mathpunct{}\nonscript
  \mkern-\thinmuskip{:}\mskip2muplus1mu\relax}


\NewDocumentCommand\tikzgrid{O{<.->}}{
\node (ll) at (.02,.02) {};
\node (ur) at (4.98,4.98) {};
\draw[draw=none,name path=outbox,use as bounding box] (-1,-1) rectangle (6,6);
% note: coordinates not multiples of step size => tikz omits the borders
\draw[decorate,style=help lines,on layer=grid,visible on=#1] (ll.center) grid[step=0.5cm] (ur.center);
%\patchcmd\auxspec{+}{.}{}{}
\draw[decorate,style=help lines,name path=boundary,on layer=grid,visible on=#1] (ll.center) rectangle (ur.center);
}

\NewDocumentCommand\tikzcone{O{<.->} O{0} m o m o m O{1}}{
% args:
	% #1 visible on (default <.->)
	% #2 set to 1 to increment slide counter before showing
	% #3 node 1
	% #4 node 2 (default node 1)
	% #5 angle -- if angle is negative, draw cone facing dl instead of ur
	% #6 path to intersect (default none (attached to point))
	% #7 fill color
	% #8 fill opacity (default 1)

	\IfValueTF{#6}{
		\IfValueTF{#4}{
			\tikzconeint{#1}{#3}{#4}{#5}{#6}{#7}{#8}{#2}
		}{
			\tikzconeint{#1}{#3}{#3}{#5}{#6}{#7}{#8}{#2}
			}
			}{
				\IfValueTF{#4}{
					\tikzconepointint{#1}{#3}{#4}{#5}{#6}{#7}{#8}{#2}
		}{
			\tikzconepointint{#1}{#3}{#3}{#5}{#6}{#7}{#8}{#2}
			}
			}

}

\def\auxconelength{10cm}
\NewDocumentCommand\tikzconeint{mmmmmmmm}{

	\ifnum#8=1\tikzinvisibledot{#2}\else\fi % due to black latex magic, this seems to be the only way to make the overlay spec increment behave as expected

\begin{scope}[visible on=#1]

	\pgfmathsetmacro\mirrorflag{#4<0}
	\ifnum \mirrorflag=1
		\pgfmathsetmacro\myangle{360-#4}
	\else
		\pgfmathsetmacro\myangle{#4}
	\fi

% get end points for the cone
	\pgfmathsetmacro\resulta{-(\myangle/2-45)}
	\pgfmathsetmacro\resultb{-(\myangle/2-45)+180}
	\pgfmathsetmacro\resultc{\myangle/2+45}
	\pgfmathsetmacro\resultd{\myangle/2+45+180}

	\draw[draw=none,name path=bconer] (#2.center) -- ++(\resulta:\auxconelength) (#2.center) -- ++(\resultb:\auxconelength);
	\draw[draw=none,name path=bconel] (#3.center) -- ++(\resultc:\auxconelength) (#3.center) -- ++(\resultd:\auxconelength);
	\path[name intersections={of=bconel and outbox,by=i1}];
	\path[name intersections={of=bconel and #5,by=j1}];
	\path[name intersections={of=bconer and outbox,by=i2}];
	\path[name intersections={of=bconer and #5,by=j2}];

	%% build cone boundaries
	\path[name path=bconeldec,decorate] (j1.center) to (i1.center);
	\path[name path=bconerdec,decorate] (j2.center) to (i2.center);


	% draw cone boundaries

	\path[
		name path=conel1,
		intersection segments={
		of=bconeldec and #5,
		sequence={A1}
		 } ];
	\path[
		draw=black,
		ultra thin,
		name path=conel,
		intersection segments={
		of=conel1 and boundary,
		sequence={A0}
		 } ];
	\path[
		name path=coner1,
		intersection segments={
		of=bconerdec and #5,
		sequence={A1}
		 } ];
	\path[
		draw=black,
		ultra thin,
		name path=coner,
		intersection segments={
		of=coner1 and boundary,
		sequence={A0}
		 } ];


	%	 % fill the cone (need to get boundaries for that first)
	\ifnum\mirrorflag=1
	\path[
		name path=fill1,
		intersection segments={
		of=boundary and bconerdec,
		sequence={A0 -- B0}
		 } ];
	 \else
	\path[
		name path=fill1,
		intersection segments={
		of=boundary and bconerdec,
		sequence={A0 -- B0[reverse]}
		 } ];
	\fi
	\ifnum\mirrorflag=1
	\path[
		name path=fill2,
		intersection segments={
		of=fill1 and #5,
		sequence={A0 -- B0[reverse]}
		 } ];
	 \else
	\path[
		name path=fill2,
		intersection segments={
		of=fill1 and #5,
		sequence={A0 -- B0[reverse]}
		 } ];
	 \fi
	 \ifnum\mirrorflag=1
	\path[
		name path=filllower,
		intersection segments={
		of=bconeldec and boundary,
		sequence={A0 -- B1}
		 } ];
	\path[
		name path=fill,
		fill=#6,
		fill opacity=#7,
		on layer=bg,
		visible on=#1,
		intersection segments={
		of=fill2 and filllower,
		sequence={A0[reverse] -- B1[reverse]}
		 } ]--cycle;
	 \else
	\path[
		name path=fill,
		fill=#6,
		fill opacity=#7,
		on layer=bg,
		visible on=#1,
		intersection segments={
		of=fill2 and bconeldec,
		sequence={A1 -- B1}
		 } ]--cycle;
	 \fi

\end{scope}
	}


		\NewDocumentCommand\tikzdot{O{<.->} m O{black} o}{
			% #1: visible on
			% #2: node
			% #3: color
			% #4: label
			\path[draw=#3,fill=#3,visible on=#1] (#2) circle [radius=1pt];

			\IfValueTF{#4}{
				\onslide#1{
					\node[mylabel=#4,visible on=#1] at (#2){};
					}
				}{
				}
			}

		\NewDocumentCommand\tikzinvisibledot{O{<+->} m }{
			% #1: visible on
			% #2: node
			\path[draw=none,visible on=#1] (#2) circle [radius=1pt];
			}

			\NewDocumentCommand\tikzpause{}{
				\node (auxnode) at (0,0) {};
				\tikzinvisibledot{auxnode}}

			\NewDocumentCommand\tikzlabel{O{<.->} m O{black} m}{
			% #1: visible on
			% #2: node
			% #3: color
			% #4: label
				\node[visible on=#1,color=#3] at (#2) {#4};
				}

\newcommand\subheading[1]{\vspace{15pt}\centering{\structure{#1}}\vspace{-8pt}}





%%%%%%%%%%%%%%%%%%%%%%%
% GO GO GO!           %
%%%%%%%%%%%%%%%%%%%%%%%

\makeatletter
\pgfkeys{%
/tikz/on layer/.code={
\pgfonlayer{#1}\begingroup
\aftergroup\endpgfonlayer
\aftergroup\endgroup
}
}
\makeatother

\makeatletter
%%%%                        ---- Use path several times
%%%%                        ---- thanks to Andrew Stacey
\makeatletter
\tikzset{
use path for main/.code={%
\tikz@addmode{%
\expandafter\pgfsyssoftpath@setcurrentpath\csname tikz@intersect@path@name@#1\endcsname
}%
},
use path for actions/.code={%
\expandafter\def\expandafter\tikz@preactions\expandafter{\tikz@preactions\expandafter\let\expandafter\tikz@actions@path\csname tikz@intersect@path@name@#1\endcsname}%
},
use path/.style={%
use path for main=#1,
use path for actions=#1,
}
}
\makeatother

\tikzset{HandFill/.style={%
thick,
line cap=round,
line join=round,
opacity=.95
}
}

\NewDocumentCommand{\HandFill}{%
D<>{1pt}    % lines density
O{10}       % lines angle
m           % path-cyle to fill
m           % starting point inside the path    
O{orange!40}% lines color
D<>{10}     % lines length for intersection 
}{%

% fill above an below the starting point
\foreach \z in {-1,1} {%

% Create the intersection points
\begin{scope}[shift=#4,rotate=#2]
\clip[use path=#3] ;
\pgfmathtruncatemacro\i{0}
\loop
\path[name path=trait, % randomize density of lines
shift={(0,\z*(.5*\i*#1+rand*.2*#1))}]
(-#6,0)--(#6,0) ;
\path[name intersections={%
of=trait and #3,
name=\i-A,
total=\t}]
\pgfextra{\xdef\InterNb{\t}} ;    
\pgfmathtruncatemacro\i{\i+1}
\ifnum\InterNb>0
\repeat
\pgfmathtruncatemacro\i{\i-3}
\xdef\i{\i}
\end{scope}

\foreach \k in {1,3,...,\i} {
\pgfmathtruncatemacro\j{\k-1}
\pgfmathtruncatemacro\l{\k+1}    
%randomize length of lines
\coordinate (\k-A-2) at ($(\k-A-2)!rand*.015!(\j-A-1)$) ;
\coordinate (\l-A-1) at ($(\l-A-1)!rand*.015!(\k-A-2)$) ;
\draw[HandFill,#5] (\j-A-1) -- (\k-A-2) -- (\l-A-1)  ;
} % end foreach \k
} % end foreach \z
} % end command




% introduce a "visible on" option for tikz:

 \tikzset{
	     invisible/.style={opacity=0},
		     visible on/.style={alt={#1{}{invisible}}},
			     alt/.code args={<#1>#2#3}{%
					       \alt<#1>{\pgfkeysalso{#2}}{\pgfkeysalso{#3}} % \pgfkeysalso doesn't change the path
						       },
							     }


